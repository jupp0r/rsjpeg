use nom::{be_u16, be_u8, Needed};

use failure::Error;

use errors::ParserError;

#[derive(Debug, Eq, PartialEq)]
pub enum Marker<'a> {
    Other(SomeMarker<'a>),
    DHT(DefineHuffmanTable),
    Image(ImageStream<'a>),
}

#[derive(Debug, Eq, PartialEq)]
pub struct SomeMarker<'a> {
    pub tag: u8,
    pub length: u16,
    pub data: &'a [u8],
}

#[derive(Debug, Eq, PartialEq)]
pub enum DHTType {
    LuminanceDC,
    LuminanceAC,
    ChrominanceDC,
    ChrominanceAC,
}

#[derive(Debug, Eq, PartialEq)]
pub struct DefineHuffmanTable {
    pub class: DHTType,
    pub symbols: [Vec<u16>; 16],
}

#[derive(Debug, Eq, PartialEq)]
pub struct ImageStream<'a> {
    pub metadata: &'a [u8],
    pub data: &'a [u8],
}

named!(
    start_of_stream<&[u8], Marker>,
    do_parse!(
        tag!(b"\xff\xda")
            >> length: be_u16
            >> metadata: take!(length - 2)
            >> data: take_until!(&b"\xff\xd9"[..])
            >> (Marker::Image(ImageStream{ metadata, data }))
    )
);

named!(huffman_table<&[u8], Marker>,
    map!(
        do_parse!(
        tag!(b"\xff\xc4")
        >> take!(2)
        >> id_class: bits!(pair!(take_bits!(u8, 4), take_bits!(u8, 4)))
        >> symbols_length: count_fixed!(u8, be_u8, 16)
        >> s1: count!(bits!(take_bits!(u16, 1)), symbols_length[0].into())
        >> s2: count!(bits!(take_bits!(u16, 2)), symbols_length[1].into())
        >> s3: count!(bits!(take_bits!(u16, 3)), symbols_length[2].into())
        >> s4: count!(bits!(take_bits!(u16, 4)), symbols_length[3].into())
        >> s5: count!(bits!(take_bits!(u16, 5)), symbols_length[4].into())
        >> s6: count!(bits!(take_bits!(u16, 6)), symbols_length[5].into())
        >> s7: count!(bits!(take_bits!(u16, 7)), symbols_length[6].into())
        >> s8: count!(bits!(take_bits!(u16, 8)), symbols_length[7].into())
        >> s9: count!(bits!(take_bits!(u16, 9)), symbols_length[8].into())
        >> s10: count!(bits!(take_bits!(u16, 10)), symbols_length[9].into())
        >> s11: count!(bits!(take_bits!(u16, 11)), symbols_length[10].into())
        >> s12: count!(bits!(take_bits!(u16, 12)), symbols_length[11].into())
        >> s13: count!(bits!(take_bits!(u16, 13)), symbols_length[12].into())
        >> s14: count!(bits!(take_bits!(u16, 14)), symbols_length[13].into())
        >> s15: count!(bits!(take_bits!(u16, 15)), symbols_length[14].into())
        >> s16: count!(bits!(take_bits!(u16, 16)), symbols_length[15].into())
        >> (DefineHuffmanTable{
            class: match id_class {
                (0,0) => DHTType::LuminanceDC,
                (0,1) => DHTType::LuminanceAC,
                (1,0) => DHTType::ChrominanceDC,
                (1,1) => DHTType::ChrominanceAC,
                _ => return Err(nom::Err::Incomplete(Needed::Size(5)))
            },
            symbols: [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16],
        })
    ), |v| Marker::DHT(v))
);

named!(some_marker<&[u8], Marker>,
    do_parse!(
        tag!(b"\xff")
        >> tag: be_u8
        >> length: be_u16
        >> data: take!(length - 2)
        >> (Marker::Other(SomeMarker{tag, length: length - 2, data}))
    )
);

named!(jpeg<&[u8], (Vec<Marker>, &[u8])>, preceded!(soi, jfif));
named!(soi, tag!(b"\xff\xd8"));

named!(jfif<&[u8], (Vec<Marker>, &[u8])>,
      many_till!(alt!(
            complete!(start_of_stream)
          | complete!(huffman_table)
          | complete!(some_marker))
          , tag!(b"\xff\xd9")));

pub fn decode(jpeg_file: &[u8]) -> Result<Vec<Marker>, Error> {
    jpeg(jpeg_file)
        .map(|parsed_correctly| (parsed_correctly.1).0)
        .map_err(|e| {
            ParserError {
                reason: format!("{:?}", e),
            }
            .into()
        })
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn huffman_test() {
        let huffman_table_sample = vec![
            0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x00, 0x07, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x03, 0x02, 0x06, 0x01, 0x00,
            0x07, 0x08, 0x09, 0x0A, 0x0B, 0x01, 0x00, 0x02, 0x02, 0x03, 0x01, 0x01, 0x01, 0x01,
            0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x03, 0x04, 0x05,
            0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04,
            0x02, 0x06, 0x07, 0x03, 0x04, 0x02, 0x06, 0x02, 0x73, 0x01, 0x02, 0x03, 0x11, 0x04,
            0x00, 0x05, 0x21, 0x12, 0x31, 0x41, 0x51, 0x06, 0x13, 0x61, 0x22, 0x71, 0x81, 0x14,
            0x32, 0x91, 0xA1, 0x07, 0x15, 0xB1, 0x42, 0x23, 0xC1, 0x52, 0xD1, 0xE1, 0x33, 0x16,
            0x62, 0xF0, 0x24, 0x72, 0x82, 0xF1, 0x25, 0x43, 0x34, 0x53, 0x92, 0xA2, 0xB2, 0x63,
            0x73, 0xC2, 0x35, 0x44, 0x27, 0x93, 0xA3, 0xB3, 0x36, 0x17, 0x54, 0x64, 0x74, 0xC3,
            0xD2, 0xE2, 0x08, 0x26, 0x83, 0x09, 0x0A, 0x18, 0x19, 0x84, 0x94, 0x45, 0x46, 0xA4,
            0xB4, 0x56, 0xD3, 0x55, 0x28, 0x1A, 0xF2, 0xE3, 0xF3, 0xC4, 0xD4, 0xE4, 0xF4, 0x65,
            0x75, 0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5, 0x66, 0x76, 0x86, 0x96, 0xA6,
            0xB6, 0xC6, 0xD6, 0xE6, 0xF6, 0x37, 0x47, 0x57, 0x67, 0x77, 0x87, 0x97, 0xA7, 0xB7,
            0xC7, 0xD7, 0xE7, 0xF7, 0x38, 0x48, 0x58, 0x68, 0x78, 0x88, 0x98, 0xA8, 0xB8, 0xC8,
            0xD8, 0xE8, 0xF8, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79, 0x89, 0x99, 0xA9, 0xB9, 0xC9,
            0xD9, 0xE9, 0xF9, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A, 0x8A, 0x9A, 0xAA, 0xBA, 0xCA,
            0xDA, 0xEA, 0xFA, 0x11, 0x00, 0x02, 0x02, 0x01, 0x02, 0x03, 0x05, 0x05, 0x04, 0x05,
            0x06, 0x04, 0x08, 0x03, 0x03, 0x6D, 0x01, 0x00, 0x02, 0x11, 0x03, 0x04, 0x21, 0x12,
            0x31, 0x41, 0x05, 0x51, 0x13, 0x61, 0x22, 0x06, 0x71, 0x81, 0x91, 0x32, 0xA1, 0xB1,
            0xF0, 0x14, 0xC1, 0xD1, 0xE1, 0x23, 0x42, 0x15, 0x52, 0x62, 0x72, 0xF1, 0x33, 0x24,
            0x34, 0x43, 0x82, 0x16, 0x92, 0x53, 0x25, 0xA2, 0x63, 0xB2, 0xC2, 0x07, 0x73, 0xD2,
            0x35, 0xE2, 0x44, 0x83, 0x17, 0x54, 0x93, 0x08, 0x09, 0x0A, 0x18, 0x19, 0x26, 0x36,
            0x45, 0x1A, 0x27, 0x64, 0x74, 0x55, 0x37, 0xF2, 0xA3, 0xB3, 0xC3, 0x28, 0x29, 0xD3,
            0xE3, 0xF3, 0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4, 0x65, 0x75, 0x85, 0x95,
            0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5, 0x46, 0x56, 0x66, 0x76, 0x86, 0x96, 0xA6, 0xB6,
            0xC6, 0xD6, 0xE6, 0xF6, 0x47, 0x57, 0x67, 0x77, 0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7,
            0xE7, 0xF7, 0x38, 0x48, 0x58, 0x68, 0x78, 0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8,
            0xF8, 0x39, 0x49, 0x59, 0x69, 0x79, 0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9,
            0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A, 0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA,
        ];

        assert_eq!(
            huffman_table(&huffman_table_sample),
            Ok((
                vec![].as_slice(),
                Marker::DHT(DefineHuffmanTable {
                    class: DHTType::LuminanceDC,
                    symbols: [
                        vec![],
                        vec![0x1, 0x2],
                        vec![0x3],
                        vec![0x11, 0x4, 0x0],
                        vec![0x5, 0x21, 0x12],
                        vec![0x31, 0x41],
                        vec![0x51, 0x6, 0x13, 0x61],
                        vec![0x22, 0x71],
                        vec![0x81, 0x14, 0x32, 0x91, 0xA1, 0x07],
                        vec![0x15, 0xB1, 0x42, 0x23, 0xC1, 0x52, 0xD1],
                        vec![0xE1, 0x33, 0x16],
                        vec![0x62, 0xF0, 0x24, 0x72],
                        vec![0x82, 0xF1],
                        vec![0x25, 0x43, 0x34, 0x53, 0x92, 0xA2],
                        vec![0xB2, 0x63],
                        vec![
                            0x73, 0xC2, 0x35, 0x44, 0x27, 0x93, 0xA3, 0xB3, 0x36, 0x17, 0x54, 0x64,
                            0x74, 0xC3, 0xD2, 0xE2, 0x08, 0x26, 0x83, 0x09, 0x0A, 0x18, 0x19, 0x84,
                            0x94, 0x45, 0x46, 0xA4, 0xB4, 0x56, 0xD3, 0x55, 0x28, 0x1A, 0xF2, 0xE3,
                            0xF3, 0xC4, 0xD4, 0xE4, 0xF4, 0x65, 0x75, 0x85, 0x95, 0xA5, 0xB5, 0xC5,
                            0xD5, 0xE5, 0xF5, 0x66, 0x76, 0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6,
                            0xF6, 0x37, 0x47, 0x57, 0x67, 0x77, 0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7,
                            0xE7, 0xF7, 0x38, 0x48, 0x58, 0x68, 0x78, 0x88, 0x98, 0xA8, 0xB8, 0xC8,
                            0xD8, 0xE8, 0xF8, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79, 0x89, 0x99, 0xA9,
                            0xB9, 0xC9, 0xD9, 0xE9, 0xF9, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A, 0x8A,
                            0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA
                        ],
                    ],
                })
            ))
        )
    }

    #[test]
    fn decode_test() {
        let minimal_jpeg = vec![
            0xFF, 0xD8, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03,
            0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x06, 0x04, 0x04, 0x04, 0x04, 0x04,
            0x08, 0x06, 0x06, 0x05, 0x06, 0x09, 0x08, 0x0A, 0x0A, 0x09, 0x08, 0x09, 0x09, 0x0A,
            0x0C, 0x0F, 0x0C, 0x0A, 0x0B, 0x0E, 0x0B, 0x09, 0x09, 0x0D, 0x11, 0x0D, 0x0E, 0x0F,
            0x10, 0x10, 0x11, 0x10, 0x0A, 0x0C, 0x12, 0x13, 0x12, 0x10, 0x13, 0x0F, 0x10, 0x10,
            0x10, 0xFF, 0xC9, 0x00, 0x0B, 0x08, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x11, 0x00,
            0xFF, 0xCC, 0x00, 0x06, 0x00, 0x10, 0x10, 0x05, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01,
            0x00, 0x00, 0x3F, 0x00, 0xD2, 0xCF, 0x20, 0xFF, 0xD9,
        ];

        assert_eq!(
            decode(&minimal_jpeg[..]).unwrap(),
            vec![
                Marker::Other(SomeMarker {
                    tag: 0xdb,
                    length: 0x41,
                    data: &[
                        0x00, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x02, 0x02, 0x02, 0x03,
                        0x03, 0x03, 0x03, 0x04, 0x06, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x06,
                        0x06, 0x05, 0x06, 0x09, 0x08, 0x0A, 0x0A, 0x09, 0x08, 0x09, 0x09, 0x0A,
                        0x0C, 0x0F, 0x0C, 0x0A, 0x0B, 0x0E, 0x0B, 0x09, 0x09, 0x0D, 0x11, 0x0D,
                        0x0E, 0x0F, 0x10, 0x10, 0x11, 0x10, 0x0A, 0x0C, 0x12, 0x13, 0x12, 0x10,
                        0x13, 0x0F, 0x10, 0x10, 0x10
                    ]
                }),
                Marker::Other(SomeMarker {
                    tag: 0xc9,
                    length: 0x9,
                    data: &[0x08, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x11, 0x00]
                }),
                Marker::Other(SomeMarker {
                    tag: 0xcc,
                    length: 0x4,
                    data: &[0x00, 0x10, 0x10, 0x05]
                }),
                Marker::Image(ImageStream {
                    metadata: &[0x01, 0x01, 0x00, 0x00, 0x3F, 0x00],
                    data: &[0xD2, 0xCF, 0x20]
                })
            ]
        );
    }
}
